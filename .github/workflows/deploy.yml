name: Bootstrap & Deploy: Lambda + API Gateway + DynamoDB

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

permissions:
  id-token: write     # for OIDC (recommended)
  contents: read

env:
  SERVICE_NAME: express-dynamodb-backend
  AWS_REGION: ${{ secrets.AWS_REGION }}                # e.g. us-east-1
  TABLE_NAME: ${{ secrets.DDB_TABLE || 'Items' }}      # default Items if not set
  LAMBDA_NAME: ${{ secrets.LAMBDA_FUNCTION_NAME || 'express-dynamodb-backend-fn' }}
  API_NAME: ${{ secrets.API_NAME || 'express-dynamodb-backend-api' }}
  LAMBDA_ALIAS: ${{ secrets.LAMBDA_ALIAS || '' }}      # optional; e.g., prod

jobs:
  bootstrap-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js 20
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Install & prune (production only)
        run: |
          npm ci
          npm prune --production

      - name: Create deployment zip
        run: |
          mkdir -p build
          zip -r build/backend.zip . \
            -x ".git/*" ".github/*" "build/*" "node_modules/.bin/*" "node_modules/aws-sdk/*"

      # ---------- AWS auth: choose ONE of the two blocks below ----------
      # (A) Recommended: OIDC role (no long-lived keys). Create a role in AWS with a trust policy for GitHub OIDC.
      - name: Configure AWS credentials (OIDC)
        if: env.AWS_REGION != '' && secrets.AWS_ROLE_ARN != ''
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      # (B) Alternative: Access keys (only if you cannot use OIDC)
      - name: Configure AWS credentials (Access Keys)
        if: env.AWS_REGION != '' && secrets.AWS_ACCESS_KEY_ID != '' && secrets.AWS_SECRET_ACCESS_KEY != '' && secrets.AWS_ROLE_ARN == ''
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      # ------------------------------------------------------------------

      - name: Install tooling
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq

      - name: Discover AWS account
        id: id
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "account_id=$ACCOUNT_ID" >> "$GITHUB_OUTPUT"

      - name: Ensure DynamoDB table exists
        run: |
          set -e
          if ! aws dynamodb describe-table --table-name "$TABLE_NAME" >/dev/null 2>&1; then
            echo "Creating DynamoDB table $TABLE_NAME..."
            aws dynamodb create-table \
              --table-name "$TABLE_NAME" \
              --attribute-definitions AttributeName=id,AttributeType=S \
              --key-schema AttributeName=id,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST
            aws dynamodb wait table-exists --table-name "$TABLE_NAME"
          else
            echo "DynamoDB table $TABLE_NAME already exists."
          fi

      - name: Ensure IAM role for Lambda exists (and has policy)
        id: role
        run: |
          set -e
          ROLE_NAME="${SERVICE_NAME}-lambda-exec-role"
          if ! aws iam get-role --role-name "$ROLE_NAME" >/dev/null 2>&1; then
            echo "Creating IAM role $ROLE_NAME..."
            cat > trust.json <<'EOF'
            {
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Effect": "Allow",
                  "Principal": { "Service": "lambda.amazonaws.com" },
                  "Action": "sts:AssumeRole"
                }
              ]
            }
            EOF
            aws iam create-role --role-name "$ROLE_NAME" --assume-role-policy-document file://trust.json
            # Basic logging
            aws iam attach-role-policy --role-name "$ROLE_NAME" --policy-arn arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
          else
            echo "IAM role $ROLE_NAME already exists."
          fi

          # Inline policy for DynamoDB access to the specific table
          ACCOUNT_ID="${{ steps.id.outputs.account_id }}"
          REGION="${AWS_REGION}"
          TABLE_ARN="arn:aws:dynamodb:${REGION}:${ACCOUNT_ID}:table/${TABLE_NAME}"
          cat > ddb-policy.json <<EOF
          {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Action": [
                  "dynamodb:PutItem",
                  "dynamodb:GetItem",
                  "dynamodb:UpdateItem",
                  "dynamodb:DeleteItem",
                  "dynamodb:Scan"
                ],
                "Resource": "${TABLE_ARN}"
              }
            ]
          }
          EOF
          aws iam put-role-policy --role-name "$ROLE_NAME" --policy-name "${SERVICE_NAME}-ddb-policy" --policy-document file://ddb-policy.json

          ROLE_ARN=$(aws iam get-role --role-name "$ROLE_NAME" --query Role.Arn --output text)
          echo "role_arn=$ROLE_ARN" >> "$GITHUB_OUTPUT"

      - name: Ensure Lambda function exists (create or update code)
        id: lambda
        run: |
          set -e
          ROLE_ARN="${{ steps.role.outputs.role_arn }}"
          HANDLER="lambda.handler"
          RUNTIME="nodejs20.x"

          if ! aws lambda get-function --function-name "$LAMBDA_NAME" >/dev/null 2>&1; then
            echo "Creating Lambda $LAMBDA_NAME..."
            aws lambda create-function \
              --function-name "$LAMBDA_NAME" \
              --role "$ROLE_ARN" \
              --runtime "$RUNTIME" \
              --handler "$HANDLER" \
              --architectures x86_64 \
              --timeout 15 \
              --memory-size 256 \
              --zip-file fileb://build/backend.zip \
              --environment "Variables={DDB_TABLE=${TABLE_NAME}}"
          else
            echo "Updating Lambda code for $LAMBDA_NAME..."
            aws lambda update-function-code \
              --function-name "$LAMBDA_NAME" \
              --zip-file fileb://build/backend.zip \
              --publish
            # Preserve other vars; ensure DDB_TABLE present
            CUR=$(aws lambda get-function-configuration --function-name "$LAMBDA_NAME")
            CURV=$(echo "$CUR" | jq -r '.Environment.Variables // {}')
            NEWV=$(echo "$CURV" | jq --arg DDB_TABLE "$TABLE_NAME" '. + {DDB_TABLE: $DDB_TABLE}')
            aws lambda update-function-configuration \
              --function-name "$LAMBDA_NAME" \
              --environment "Variables=$NEWV"
          fi

          # Output latest version
          LATEST=$(aws lambda list-versions-by-function --function-name "$LAMBDA_NAME" --max-items 1 | jq -r '.Versions[-1].Version')
          echo "latest_version=$LATEST" >> "$GITHUB_OUTPUT"

      - name: Create/Update Lambda alias (optional)
        if: env.LAMBDA_ALIAS != ''
        run: |
          set -e
          ALIAS="$LAMBDA_ALIAS"
          FN="$LAMBDA_NAME"
          LATEST="${{ steps.lambda.outputs.latest_version }}"
          if aws lambda get-alias --function-name "$FN" --name "$ALIAS" >/dev/null 2>&1; then
            aws lambda update-alias --function-name "$FN" --name "$ALIAS" --function-version "$LATEST"
          else
            aws lambda create-alias --function-name "$FN" --name "$ALIAS" --function-version "$LATEST"
          fi

      - name: Ensure API Gateway HTTP API exists (with integration & routes)
        id: apigw
        run: |
          set -e
          API_ID=$(aws apigatewayv2 get-apis --query "Items[?Name=='${API_NAME}'].ApiId | [0]" --output text)
          if [ "$API_ID" = "None" ] || [ -z "$API_ID" ]; then
            echo "Creating HTTP API ${API_NAME}..."
            API_ID=$(aws apigatewayv2 create-api \
              --name "$API_NAME" \
              --protocol-type HTTP \
              --cors-configuration "AllowOrigins=['*'],AllowMethods=['*'],AllowHeaders=['*']" \
              --query ApiId --output text)
          else
            echo "HTTP API ${API_NAME} already exists (ApiId=$API_ID)."
            # Ensure CORS is enabled
            aws apigatewayv2 update-api --api-id "$API_ID" \
              --cors-configuration "AllowOrigins=['*'],AllowMethods=['*'],AllowHeaders=['*']" >/dev/null
          fi

          # Integration (Lambda proxy)
          REGION="${AWS_REGION}"
          FN_ARN=$(aws lambda get-function --function-name "$LAMBDA_NAME" --query Configuration.FunctionArn --output text)
          INTEGRATION_ID=$(aws apigatewayv2 get-integrations --api-id "$API_ID" --query "Items[?IntegrationUri!=null && contains(IntegrationUri, '${FN_ARN}')].IntegrationId | [0]" --output text)
          if [ "$INTEGRATION_ID" = "None" ] || [ -z "$INTEGRATION_ID" ]; then
            echo "Creating integration..."
            INTEGRATION_ID=$(aws apigatewayv2 create-integration \
              --api-id "$API_ID" \
              --integration-type AWS_PROXY \
              --integration-method ANY \
              --integration-uri "arn:aws:apigateway:${REGION}:lambda:path/2015-03-31/functions/${FN_ARN}/invocations" \
              --payload-format-version "2.0" \
              --query IntegrationId --output text)
          fi

          # Routes: ANY / and ANY /{proxy+}
          for ROUTE_KEY in "ANY /" "ANY /{proxy+}"; do
            RID=$(aws apigatewayv2 get-routes --api-id "$API_ID" --query "Items[?RouteKey=='${ROUTE_KEY}'].RouteId | [0]" --output text)
            if [ "$RID" = "None" ] || [ -z "$RID" ]; then
              echo "Creating route ${ROUTE_KEY}..."
              aws apigatewayv2 create-route --api-id "$API_ID" --route-key "$ROUTE_KEY" --target "integrations/${INTEGRATION_ID}" >/dev/null
            else
              # Ensure it targets our integration
              aws apigatewayv2 update-route --api-id "$API_ID" --route-id "$RID" --target "integrations/${INTEGRATION_ID}" >/dev/null
            fi
          done

          # Lambda permission so API Gateway can invoke
          SOURCE_ARN="arn:aws:execute-api:${REGION}:${{ steps.id.outputs.account_id }}:${API_ID}/*/*/*"
          SID="${SERVICE_NAME}-allow-apigw"
          if ! aws lambda get-policy --function-name "$LAMBDA_NAME" | jq -e ".Policy | fromjson | .Statement[] | select(.Sid==\"$SID\")" >/dev/null 2>&1; then
            echo "Adding lambda:InvokeFunction permission for API Gateway..."
            aws lambda add-permission \
              --function-name "$LAMBDA_NAME" \
              --statement-id "$SID" \
              --action lambda:InvokeFunction \
              --principal apigateway.amazonaws.com \
              --source-arn "$SOURCE_ARN"
          fi

          # Stage: $default with AutoDeploy
          if ! aws apigatewayv2 get-stages --api-id "$API_ID" --query "Items[?StageName=='$default'] | [0]" --output text >/dev/null 2>&1; then
            aws apigatewayv2 create-stage --api-id "$API_ID" --stage-name '$default' --auto-deploy
          else
            aws apigatewayv2 update-stage --api-id "$API_ID" --stage-name '$default' --auto-deploy
          fi

          # Output invoke URL
          INVOKE_URL=$(aws apigatewayv2 get-api --api-id "$API_ID" --query "ApiEndpoint" --output text)
          echo "api_id=$API_ID" >> "$GITHUB_OUTPUT"
          echo "invoke_url=$INVOKE_URL" >> "$GITHUB_OUTPUT"

      - name: Show Invoke URL
        run: |
          echo "âœ… Invoke URL: ${{ steps.apigw.outputs.invoke_url }}"

      - name: Upload deployment artifact
        uses: actions/upload-artifact@v4
        with:
          name: backend.zip
          path: build/backend.zip
